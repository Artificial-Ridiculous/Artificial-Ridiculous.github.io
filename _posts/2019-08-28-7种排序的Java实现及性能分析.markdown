---
layout: post
title:  "7种排序的Java实现及性能对比"
date:   2019-08-28 13:56:00 +0800
category: java
---

## 数据*无序*的情况下

```
堆排序800w个元素耗时1979ms
arr=[1, 3, 6, 6, 7, 7, 7, 9, 9, 9, 11, 15, 16, 20, 21, 28, 28, 30, 31, 31]省略以下700w+个数据..
----------
快速排序800w个元素耗时938ms
arr=[1, 2, 3, 4, 4, 6, 8, 10, 15, 16, 16, 18, 19, 21, 21, 21, 22, 23, 23, 25]省略以下700w+个数据..
----------
shell排序800w个元素耗时2002ms
arr=[0, 1, 2, 3, 4, 5, 6, 6, 9, 14, 15, 15, 17, 18, 19, 21, 22, 25, 26, 27]省略以下700w+个数据..
----------
归并排序800w个元素耗时1118ms
arr=[0, 5, 10, 10, 11, 15, 16, 16, 17, 18, 18, 18, 19, 19, 22, 22, 24, 24, 25, 28]省略以下700w+个数据..

Process finished with exit code 0
```

## 数据*有序*的情况下

```
堆排序800w个元素耗时621ms
arr=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]省略以下700w+个数据..
----------
快速排序
Exception in thread "main" java.lang.StackOverflowError
----------
shell排序800w个元素耗时94ms
arr=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]省略以下700w+个数据..
----------
归并排序800w个元素耗时329ms
arr=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]省略以下700w+个数据..

Process finished with exit code 0
```

---

由以上性能测试可知,快排在数据无序的情况下是4种平均时间复杂度O(NlogN)的排序算法中最优的;  
但在数据(基本)有序的情况下,快排退化成了O(N^2),甚至会溢出报错.  
相反另外三种排序在数据基本有序的情况下由于比较/交换次数减少,性能获得了很大的提升.

---
## swap函数
```java
public static void swap(int[] arr ,int i,int j){
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```


## 冒泡排序 Bubble
```java
public static void bubble(int[] arr){
    System.out.println("冒泡排序");
    for (int j = 0; j < arr.length; j++) {
        for (int i = 0; i < arr.length - 1 -j; i++) {
            if(arr[i] > arr[i+1]){
                swap(arr,i,i+1);
            }

        }
    }
}
```

## 选择排序 Choose
```java
public static void choose(int[] l){
    System.out.println("简单选择排序");
    for (int i = 0; i < l.length-1; i++) {
        int index = 0;
        for (int j = 0; j < l.length-i; j++) {
            if(l[j]>l[index]){
                index = j;
            }
        }
        swap(l,index,l.length-i-1);
    }
}
```

## 插入排序 Insert
```java
public static void insert(int[] l) {
    System.out.println("简单插入排序");
    for (int i = 1; i < l.length; i++) {
        int val = l[i];
        int index = i-1;
        while(index >=0 && val<l[index]){
            l[index+1] = l[index];
            index--;
        }
        l[index+1] = val;
    }
}
```

## 希尔排序 Shell
```java
public static void shell(int[] l){
    System.out.println("希尔排序");
    int len = l.length;
    int step = len;
    int val = 0;
    int index = 0;
    //最后一步步长为1   1/2==0
    while((step /= 2) > 0){
        //一共有step组 每组有一个内循环来处理
        // 这里i从step开始 不是从length-step开始   类比插入排序
        for (int i = step; i < len; i++) {  
            //内层循环  每个循环解决一组
            val = l[i];
            index = i-step;
            while(index>=0 && val < l[index]){
                l[index+step] = l[index];
                index-=step;
            }
            l[index+step]=val;
        }
    }
}
```

## 快速排序 Fast
```java
public static void fast(int[] l){
    System.out.println("快速排序");
    int len = l.length;
    fast(l,0,len-1);
}

private static void fast(int[] l, int i,int j){
    if(j<=i){
        return;
    }
    int target = l[i];
    int left = i; // 是i不是i+1!!!
    int right = j;
    while(left != right){
        //停止条件是相遇 或者遇到比target小的元素
        while (right!=left && l[right]>= target){
            right--;
        }
        //停止条件是相遇 或者遇到比target大的元素
        while(left!=right && l[left]<=target){
            left++;
        }
        swap(l,right,left);
    }
    swap(l,right,i);
    fast(l,i,right-1);
    fast(l,right+1,j);
}
```

## 归并排序 Merge
```java
public static void mergeSort(int[] l){
    System.out.println("归并排序");
    int len = l.length;
    int[] tmp = new int[len];
    mergeSort(l,tmp,0,len-1);
}

private static void mergeSort(int[] l , int [] tmp,int i,int j){
    if(i>=j){
        return;
    }else{
        int mid = (i+j)/2;
        mergeSort(l,tmp,i,mid);
        mergeSort(l,tmp,mid+1,j);
        merge2SortedList(l,i,mid,j,tmp);
    }
}

private static void merge2SortedList(int[] l ,int left, int mid, int right, int[] tmp){
    int index = left;
    int i = left;
    int j = mid+1;
    while(i<= mid && j<=right){
        if(l[i]<=l[j]){
            tmp[index] = l[i];
            i++;
            index++;
        }else{
            tmp[index]=l[j];
            j++;
            index++;
        }
    }
    //有一边已经全部拷完了
    while(i<=mid){
        tmp[index] = l[i];
        index++;
        i++;
    }
    while(j<=right){
        tmp[index] = l[j];
        index++;
        j++;
    }
    //往原始数组拷
    for (int k = left; k <= right; k++) {  // 是<=不是<
        l[k] = tmp[k];
    }
}
```

## 堆排序 Heap
```java
public static void heapSort(int[] arr){
    System.out.println("堆排序");
    int lastIndex = arr.length-1;

    //(arr.length-2)/2 是最后一个有子节点的节点下标
    for (int index = (arr.length-2)/2; index >= 0 ; index--) {
        // 构建初始的全局大顶堆  大概是nlogn的时间复杂度
        adjustHeap(arr,index,lastIndex);
    }

    for(;lastIndex>=1;lastIndex--){
        // 将堆顶元素与堆最后一个元素互换
        swap(arr,0,lastIndex);
        // 将堆的size-1   重新构建大顶堆
        //大约logn的时间复杂度
        adjustHeap(arr,0,lastIndex-1);
    }
}
private static void adjustHeap(int[] arr,int root,int lastIndex){ // 根据last,调整使之成为大顶堆
    int current = root;
    int left = 2*current+1;
    int right = 2*current+2;
    // 连左孩子都没有  直接无需调整
    if(left>lastIndex){
        return;
    // 如果有左孩子但没右孩子
    } else if(right>lastIndex){
        //如果左孩子比自己大
        if(arr[left]>arr[current]){
            //交换
            swap(arr,left,current);
            //交换后要重新以左孩子为起点 向下adjust堆
            adjustHeap(arr,left,lastIndex);
        }
    //既有左孩子又有右孩子
    }else{
        //先找最大的孩子
        if(arr[right]> arr[left]){
            //如果左孩子大 再跟current比
            if(arr[right]>arr[current]){
                swap(arr,right,current);
                //交换后要重新以右孩子为起点 向下adjust堆
                adjustHeap(arr,right,lastIndex);
            }
        }else{
            if(arr[left]>arr[current]){
                //如果右孩子大 再跟current比
                swap(arr,left,current);
                //交换后要重新以左孩子为起点 向下adjust堆
                adjustHeap(arr,left,lastIndex);
            }
        }
    }
}
```

