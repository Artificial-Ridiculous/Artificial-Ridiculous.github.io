---
layout: post
title:  "数据库范式"
date:   2019-06-03 10:13:00 +0800
categories: MySQL
---

condition|1NF|2NF|3NF|备注
-|-|-|-|-
主键|<font color=green>o</font>|<font color=green>o</font>|<font color=green>o</font>|没有完全重复的元组，若有则需加上唯一标识符
无重复组|<font color=green>o</font>|<font color=green>o</font>|<font color=green>o</font>|一个方框中只有一条记录，否则需要拆分为2个元组
字段原子性|<font color=green>o</font>|<font color=green>o</font>|<font color=green>o</font>|字段不可再分
没有部份依赖函数|<font color=red>x</font>|<font color=green>o</font>|<font color=green>o</font>|数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系
没有传递函数依赖|<font color=red>x</font>|<font color=red>x</font>|<font color=green>o</font>|

---

## 第一范式

**第一范式**（1NF）是数据库正规化所使用的正规形式。第一范式是为了要排除*重复组*的出现，所采用的方法是要求数据库的每个列的值域都是由原子值组成；每个字段的值都只能是单一值。

### 主键

Customer|Date|Amount
--------|----|--------
Pete|Wednesday|-84.00
Pete|Wednesday|-84.00

上表中，有人在同一天有相同的交易金额，缺乏唯一识别码（主键），元组无法被唯一区分，应做如下调整：

Transaction ID|Customer|Date|Amount
--------------|--------|----|------
1|Pete|Wednesday|-84.00
2|Pete|Wednesday|-84.00

### 重复组

Customer|Date|Amount
--------|----|--------
Pete|Monday|19.00<br>-28.20
Pete|Wednesday|-84.00
Sarah|Friday|100.00<br>-40.00

上表在`Amount`列上有重复组，违反了第一范式，应改为：

Customer|Date|Amount
--------|----|--------
Pete|Monday|19.00
Pete|Monday|-28.20
Pete|Wednesday|-84.00
Sarah|Friday|100.00
Sarah|Friday|-40.00

### 字段原子性

即字段不可再分原则。

---

## 第二范式

**第二范式**（2NF）是数据库正规化所使用的正规形式。规则是要求数据表里的所有数据都要和该数据表的*键*（主键与候选键）有*完全依赖关系*：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些数据只和一个键的一部分有关的话，就得把它们独立出来变成另一个数据表。如果一个数据表的键只有单个字段的话，它就一定匹配第二范式。

一个数据表匹配第二范式当且仅当:

- 它匹配第一范式
- 所有非键的字段都一定是候选键全体字段的函数

### 没有部份依赖函数

**所有非键的字段都一定是候选键全体字段的函数**

考虑如下数据表：

<center>组件来源</center>

组件ID（主键）|价格|供应商ID（主键）|供应商名称|供应商住址
-|-|-|-|-
65|50.99|1|Stylized Parts|VA
73|20.00|1|Stylized Parts|VA
65|69.99|2|ACME Industries|CA

这个数据表的每个值都是单一值，所以它匹配第一范式。因为同一个组件有可能由不同的供应商提供，所以得把组件 ID 和供应商 ID 合在一起组成一个主键。

组件（关键词）和价格之间的关系很正确：同一个组件在不同供应商有可能会有不同的报价，所以价格确实和主键完全相关（完全依赖）。

另一方面，供应商的名称和住址就只和供应商 ID 有关（部分依赖），这不匹配第二范式的原则。仔细看就会发现 "Stylized Parts" 这个名称和 "VA" 这个住址重复出现了两次；要是它改名了或是被其他公司并购了怎么办？这时候最好把这些数据存到第二个数据表中：

<center>供应商</center>

供应商 ID （主键）|名称|住址
-|-|-
1|Stylized Parts|VA
2|ACME Industries|CA

这么一来，原本的 "组件来源" 数据表就得要做相对应的改动：

<center>组件来源</center>

组件ID（主键主键）|价格|供应商ID（主键）
-|-|-
65|50.99|1
73|20.00|1
65|69.99|2

检查数据表里的每个字段，确认它们是不是都和关键词完全相关， 这样才能知道这个数据表是不是匹配第二范式； 如果不是的话，就把那些不完全相关的字段移到独立的数据表里。 接下来的步骤是要确保所有不是键的字段都和彼此没有相依关系，这就叫做**第三范式**。

---

## 第三范式

**第三范式**（3NF）是数据库正规化所使用的正规形式，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。

### 正规定义

令：

- **R** 表一个关系
- **F**表维持**R**所需的一组依赖函数
- **X**表**R**属性的子集合
- **A**表**R**的一个属性

如果对于 `X -> A` 这种型式的函数依赖而言，下列叙述任一为真的话，则可以称  `R` 匹配第三范式：

- A
- 
- 

$$
        \begin{pmatrix}
        1 & a_1 & a_1^2 & \cdots & a_1^n \\
        1 & a_2 & a_2^2 & \cdots & a_2^n \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        1 & a_m & a_m^2 & \cdots & a_m^n \\
        \end{pmatrix}
$$